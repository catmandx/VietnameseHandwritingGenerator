<html>
    <head>
        <script src="/static/js/jquery-3.6.0.min.js"></script>
        <style>
            @font-face {
                font-family: HP001-Normal;
                src: url(/static/font/HP001N30.ttf);
            }
            @font-face {
                font-family: HP001-Bold;
                src: url(/static/font/HP001B30.ttf);
            }
        </style>
        <script>
            //utils
            function getUnicodeStr(word){
                console.log(word)
                let charArr = word.split('');
                //join phu am ghep kh nh ch gh ph th
                let i = 0
                while (i < charArr.length - 1){
                    let currChar = charArr[i];
                    let nextChar = charArr[i+1];
                    if ("kh nh ch gh ph th".split(' ').indexOf(currChar+nextChar) >= 0){
                        charArr[i] = currChar+nextChar;
                        charArr.splice(i+1,1);
                    }
                    i++;
                }
                let baseChars = charArr.map(char => removeAccents(char));
                let unicodeString = "";
                let base = null;
                let prev = null;
                let curr = null;
                let next = null;
                for (let i = 0; i < charArr.length; i++) {
                    base = baseChars[i];
                    curr = charArr[i];
                    prev = i == 0 ? null: baseChars[i-1];
                    next = i == charArr.length - 1 ? null: baseChars[i+1];
                    let glyph = getGlyph(base, prev, curr, next);
                    unicodeString += glyph;
                }
                return unicodeString;
            }

            function getGlyph(base, previous, char, next){
                console.log('getGlyph', base, previous, char, next)
                let currentSet = glyphs[base].types;
                console.log(base,currentSet)
                for (const type of currentSet) {
                    if ( type.prev.includes(previous) && type.next.includes(next)){
                        glyphs = type.accent['level'];
                        return glyphs.split(',').map(glyph => String.fromCharCode(glyph));
                    }
                }
            }

            function removeAccents(str) {
                var AccentsMap = [
                    "aàảãáạăằẳẵắặâầẩẫấậ",
                    "AÀẢÃÁẠĂẰẲẴẮẶÂẦẨẪẤẬ",
                    "dđ", "DĐ",
                    "eèẻẽéẹêềểễếệ",
                    "EÈẺẼÉẸÊỀỂỄẾỆ",
                    "iìỉĩíị",
                    "IÌỈĨÍỊ",
                    "oòỏõóọôồổỗốộơờởỡớợ",
                    "OÒỎÕÓỌÔỒỔỖỐỘƠỜỞỠỚỢ",
                    "uùủũúụưừửữứự",
                    "UÙỦŨÚỤƯỪỬỮỨỰ",
                    "yỳỷỹýỵ",
                    "YỲỶỸÝỴ"    
                ];
                for (var i=0; i<AccentsMap.length; i++) {
                    var re = new RegExp('[' + AccentsMap[i].substr(1) + ']', 'g');
                    var char = AccentsMap[i][0];
                    str = str.replace(re, char);
                }
                return str;
            }

            function stripHtml(str){
                return str.replace(/(<([^>]+)>)/gi, "");
            }
            
            function decodeHTMLEntities(text) {
                // Create a new element or use one from cache, to save some element creation overhead
                const el = decodeHTMLEntities.__cache_data_element 
                        = decodeHTMLEntities.__cache_data_element 
                        || document.createElement('div');
                
                const enc = text
                    // Prevent any mixup of existing pattern in text
                    .replace(/⪪/g, '⪪#')
                    // Encode entities in special format. This will prevent native element encoder to replace any amp characters
                    .replace(/&([a-z1-8]{2,31}|#x[0-9a-f]+|#\d+);/gi, '⪪$1⪫');

                // Encode any HTML tags in the text to prevent script injection
                el.textContent = enc;

                // Decode entities from special format, back to their original HTML entities format
                el.innerHTML = el.innerHTML
                    .replace(/⪪([a-z1-8]{2,31}|#x[0-9a-f]+|#\d+)⪫/gi, '&$1;')
                    .replace(/#⪫/g, '⪫');
            
                // Get the decoded HTML entities
                const dec = el.textContent;
                
                // Clear the element content, in order to preserve a bit of memory (it is just the text may be pretty big)
                el.textContent = '';

                return dec;
            }
        </script>
    </head>
    <body>
        <h1 id="input" style="border: 2pt solid black; min-width: 100px;" contenteditable="true" ></h1>
        <h1 id="result" style="font-family: HP001-Bold;"></h1>
        <script>
            //get json data
            var glyphs = {

            }
            let list = ["a", "ă", 'â', "b", 'c', 'd', 'đ', 'e', 'ê', "i", 'k', 'l', 'm', 'n','o', 'ô', 'ơ', 'r', 's','t', 'u', 'ư', 'v', 'x', 'y'
                        ,"kh"];
            for (const base of list) {
                $.getJSON("/data/"+base+".json", function(data){
                    glyphs[base] = data;
                })
            }
            
            console.log(glyphs)

            var $input = $('#input');
            var $result = $('#result');
            $input.on('keyup',function(e){
                //type
                let words = decodeHTMLEntities($input.text()).split(" ");
                let result = []
                for (const word of words) {
                    let unicodeWord = getUnicodeStr(word);
                    result.push(unicodeWord)
                }
                $result.html(result.join(" "))
            })
        </script>
    </body>
</html>